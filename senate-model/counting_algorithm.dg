# the main algorithm

import '/collections/defaultdict'
import '/math/floor'

log = *: args **: kwargs -> print *: args **: kwargs

swap = t -> (snd t, fst t)

generate_preference_structure = preference_set ->
  results_dictionary = defaultdict (-> defaultdict (-> set!))  # definition of pref struct
  #foldl (rd pref -> 
  #        rd !! pref.owner_id !! pref.ticket_no |>.add pref
  #        rd) results_dictionary preference_set
  for pref in preference_set => results_dictionary !! pref.owner_id !! pref.ticket_no|>.add pref
  results_dictionary

lowest_preference_by_ticket = pref_struct ->
  results_dictionary = defaultdict (-> defaultdict (-> set!))  # definition of pref struct
  for (owner_id, tickets) in pref_struct.items! => 
    for (ticket_no, pref_set) in tickets.items! =>
      results_dictionary !! owner_id !! ticket_no = min pref_set
  results_dictionary

gen_int_results_table = low_pref_struct owner_votes ->
  results_table = defaultdict (-> 0)  
  for (owner_id, tickets) in low_pref_struct.items! =>
    each_ticket_n_votes = owner_votes !! owner_id / $ len tickets
    for (ticket_no, pref) in tickets.items! =>
      results_table !! pref.candidate_id += each_ticket_n_votes * pref.value
  results_table


# when someone is elected or eliminated
## anyone preferencing them last needs to modify pref value (elected only)
## prefs to the successful candidate destroyed
mod_prefs = pref_struct candidate transfer_mult_mult ->
  to_remove = set!
  for (owner, tickets) in pref_struct.items! =>
    for (ticket_no, prefs) in tickets.items! =>
      if min prefs |>.candidate_id == candidate =>  # if the lowest pref is for candidate then rescale all these votes
        for pref in prefs =>
          pref.transfer_multiplyer *= transfer_mult_mult
      for pref in prefs => pref.candidate_id == candidate => to_remove.add (owner, ticket_no, pref)
  for (owner, ticket_no, pref) in to_remove =>
    pref_struct !! owner !! ticket_no |>.remove pref
  pref_struct

# load all preferences into groups by owner_id, then ticket_no
# while unfilled seats remain
  # for each ticket_no find the lowest preference
    # allocate `owner_votes/num_tickets` by candidate_id in the intermediate results table
    # if there is a candidate with more votes than the quota:
      # log
      # fill seat
      # weight owner's preferences
      # remove successful pref from all tickets
    # otherwise find the candidate with the lowest number of votes and
      # add that candidate_id to eliminated set
      # remove any that pref from all tickets
      # debug log

run_election = pref_set vote_distribution num_seats ->
  pref_struct = generate_preference_structure pref_set
  elected = list!
  quota = floor $ 1 + $ (sum vote_distribution.values!) / $ num_seats + 1
  while len elected < num_seats =>
    low_pref_struct = lowest_preference_by_ticket pref_struct
    int_results = gen_int_results_table low_pref_struct vote_distribution
    max_votes, top_candidate = max $ map swap int_results.items!
    if
      max_votes > quota =>
        log '!! Elected  ' top_candidate 'with' max_votes 'votes'
        mod_prefs pref_struct top_candidate ((max_votes - quota) / max_votes)
        elected.append top_candidate
      otherwise =>
        min_votes, worst_candidate = min $ map swap int_results.items!
        mod_prefs pref_struct worst_candidate 1
        log '-- eliminated' worst_candidate 'with' min_votes 'votes'
  log elected 'candidates elected'
        
    
  
